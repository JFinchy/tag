import { CodeQualitySuggestion } from '../analyzers/codeQualityAnalyzer.js';
import { DiffSummary } from '../analyzers/diffAnalyzer.js';
import { SecurityIssue } from '../analyzers/securityScanner.js';

// Types
interface CommentData {
  diffSummary: DiffSummary;
  qualitySuggestions: CodeQualitySuggestion[];
  securityIssues: SecurityIssue[];
  prUrl: string;
  prTitle: string;
}

/**
 * Formats the analysis results into a GitHub comment
 * @param data - The analysis data
 * @returns Formatted comment
 */
export function formatComment(data: CommentData): string {
  const { diffSummary, qualitySuggestions, securityIssues, prTitle } = data;
  
  // Start building the comment
  let comment = `# Code Review: ${prTitle}\n\n`;
  
  // Add overall summary
  comment += `## Summary\n\n${diffSummary.overallSummary}\n\n`;
  
  // Add statistics
  comment += formatStats(diffSummary.stats);
  
  // Add security issues (if any)
  if (securityIssues.length > 0) {
    comment += formatSecurityIssues(securityIssues);
  }
  
  // Add code quality suggestions (if any)
  if (qualitySuggestions.length > 0) {
    comment += formatQualitySuggestions(qualitySuggestions);
  }
  
  // Add file summaries
  comment += formatFileSummaries(diffSummary.fileSummaries);
  
  // Add footer
  comment += '\n\n---\n*This review was automatically generated by Code Review Bot*';
  
  return comment;
}

/**
 * Formats the statistics section
 * @param stats - The diff statistics
 * @returns Formatted statistics section
 */
function formatStats(stats: DiffSummary['stats']): string {
  let statsSection = '## Statistics\n\n';
  
  statsSection += `- **Files Changed**: ${stats.totalFiles} (${stats.addedFiles} added, ${stats.modifiedFiles} modified, ${stats.deletedFiles} deleted)\n`;
  statsSection += `- **Lines Changed**: +${stats.totalAddedLines}, -${stats.totalRemovedLines}\n`;
  
  // Add file types breakdown
  if (Object.keys(stats.fileTypes).length > 0) {
    statsSection += '- **File Types**:\n';
    
    Object.entries(stats.fileTypes).forEach(([ext, count]) => {
      statsSection += `  - ${ext || 'unknown'}: ${count}\n`;
    });
  }
  
  return statsSection + '\n';
}

/**
 * Formats the security issues section
 * @param securityIssues - The security issues
 * @returns Formatted security issues section
 */
function formatSecurityIssues(securityIssues: SecurityIssue[]): string {
  let securitySection = '## Security Issues\n\n';
  
  // Count issues by severity
  const severityCounts = {
    critical: 0,
    high: 0,
    medium: 0,
    low: 0
  };
  
  securityIssues.forEach(fileIssue => {
    fileIssue.issues.forEach(issue => {
      severityCounts[issue.severity]++;
    });
  });
  
  // Add severity summary
  securitySection += '### Summary\n\n';
  securitySection += `- **Critical**: ${severityCounts.critical}\n`;
  securitySection += `- **High**: ${severityCounts.high}\n`;
  securitySection += `- **Medium**: ${severityCounts.medium}\n`;
  securitySection += `- **Low**: ${severityCounts.low}\n\n`;
  
  // Add details for critical and high issues
  if (severityCounts.critical > 0 || severityCounts.high > 0) {
    securitySection += '### Critical & High Priority Issues\n\n';
    
    securityIssues.forEach(fileIssue => {
      const criticalHighIssues = fileIssue.issues.filter(
        issue => issue.severity === 'critical' || issue.severity === 'high'
      );
      
      if (criticalHighIssues.length > 0) {
        securitySection += `#### ${fileIssue.filePath}\n\n`;
        
        criticalHighIssues.forEach(issue => {
          const lineInfo = issue.lineNumbers ? ` (lines: ${issue.lineNumbers.join(', ')})` : '';
          const cweInfo = issue.cwe ? ` [${issue.cwe}]` : '';
          
          securitySection += `- **${issue.severity.toUpperCase()}**${cweInfo}${lineInfo}: ${issue.description}\n`;
          
          if (issue.remediation) {
            securitySection += `  - **Remediation**: ${issue.remediation}\n`;
          }
        });
        
        securitySection += '\n';
      }
    });
  }
  
  // Add details for medium and low issues (collapsed)
  if (severityCounts.medium > 0 || severityCounts.low > 0) {
    securitySection += '### Medium & Low Priority Issues\n\n';
    securitySection += '<details>\n<summary>Click to expand</summary>\n\n';
    
    securityIssues.forEach(fileIssue => {
      const mediumLowIssues = fileIssue.issues.filter(
        issue => issue.severity === 'medium' || issue.severity === 'low'
      );
      
      if (mediumLowIssues.length > 0) {
        securitySection += `#### ${fileIssue.filePath}\n\n`;
        
        mediumLowIssues.forEach(issue => {
          const lineInfo = issue.lineNumbers ? ` (lines: ${issue.lineNumbers.join(', ')})` : '';
          const cweInfo = issue.cwe ? ` [${issue.cwe}]` : '';
          
          securitySection += `- **${issue.severity.toUpperCase()}**${cweInfo}${lineInfo}: ${issue.description}\n`;
          
          if (issue.remediation) {
            securitySection += `  - **Remediation**: ${issue.remediation}\n`;
          }
        });
        
        securitySection += '\n';
      }
    });
    
    securitySection += '</details>\n\n';
  }
  
  return securitySection;
}

/**
 * Formats the code quality suggestions section
 * @param qualitySuggestions - The code quality suggestions
 * @returns Formatted code quality suggestions section
 */
function formatQualitySuggestions(qualitySuggestions: CodeQualitySuggestion[]): string {
  let qualitySection = '## Code Quality Suggestions\n\n';
  
  // Count suggestions by priority
  const priorityCounts = {
    high: 0,
    medium: 0,
    low: 0
  };
  
  qualitySuggestions.forEach(suggestion => {
    priorityCounts[suggestion.priority]++;
  });
  
  // Add priority summary
  qualitySection += '### Summary\n\n';
  qualitySection += `- **High Priority**: ${priorityCounts.high}\n`;
  qualitySection += `- **Medium Priority**: ${priorityCounts.medium}\n`;
  qualitySection += `- **Low Priority**: ${priorityCounts.low}\n\n`;
  
  // Add high priority suggestions
  if (priorityCounts.high > 0) {
    qualitySection += '### High Priority Suggestions\n\n';
    
    qualitySuggestions
      .filter(suggestion => suggestion.priority === 'high')
      .forEach(suggestion => {
        qualitySection += `#### ${suggestion.filePath}\n\n`;
        
        suggestion.suggestions.forEach((text, index) => {
          const lineInfo = suggestion.lineNumbers && suggestion.lineNumbers[index]
            ? ` (line: ${suggestion.lineNumbers[index]})`
            : '';
          
          qualitySection += `- ${text}${lineInfo}\n`;
        });
        
        qualitySection += '\n';
      });
  }
  
  // Add medium and low priority suggestions (collapsed)
  if (priorityCounts.medium > 0 || priorityCounts.low > 0) {
    qualitySection += '### Medium & Low Priority Suggestions\n\n';
    qualitySection += '<details>\n<summary>Click to expand</summary>\n\n';
    
    qualitySuggestions
      .filter(suggestion => suggestion.priority === 'medium' || suggestion.priority === 'low')
      .forEach(suggestion => {
        qualitySection += `#### ${suggestion.filePath} (${suggestion.priority})\n\n`;
        
        suggestion.suggestions.forEach((text, index) => {
          const lineInfo = suggestion.lineNumbers && suggestion.lineNumbers[index]
            ? ` (line: ${suggestion.lineNumbers[index]})`
            : '';
          
          qualitySection += `- ${text}${lineInfo}\n`;
        });
        
        qualitySection += '\n';
      });
    
    qualitySection += '</details>\n\n';
  }
  
  return qualitySection;
}

/**
 * Formats the file summaries section
 * @param fileSummaries - The file summaries
 * @returns Formatted file summaries section
 */
function formatFileSummaries(fileSummaries: Record<string, string>): string {
  let summariesSection = '## File Changes\n\n';
  summariesSection += '<details>\n<summary>Click to expand file details</summary>\n\n';
  
  Object.entries(fileSummaries).forEach(([filePath, summary]) => {
    summariesSection += `### ${filePath}\n\n${summary}\n\n`;
  });
  
  summariesSection += '</details>\n';
  
  return summariesSection;
} 